# BTC中的Bloom过滤器

Bloom过滤器其实并不是用来过滤某个东西的，与其说是过滤器不入说这是一个验证器或者检验器(这种说法可能是不准确的，但是作为一个从小都是学习的中文，这样理解就相对容易一些)，验证某个东西是否在一个集合里面。那么我们就要弄清楚Bloom过滤器是怎么构成的。

## 用Bloom过滤器的目的

大家可以先去了解一下密码学中的零知识证明，零知识证明指的是证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的。

##### 举个例子：

```
1、A要向B证明自己拥有某个房间的钥匙，假设该房间只能用钥匙打开锁，而其他任何方法都打不开。这时有2个方法：
①A把钥匙出示给B，B用这把钥匙打开该房间的锁，从而证明A拥有该房间的正确的钥匙。
②B确定该房间内有某一物体，A用自己拥有的钥匙打开该房间的门，然后把物体拿出来出示给B，从而证明自己确实拥有该房间的钥匙。
后面的②方法属于零知识证明。它的好处在于，在整个证明的过程中，B始终不能看到钥匙的样子，从而避免了钥匙的泄露。
```
* Bloom存在的用处就是：
它能让用户在有效搜 索关键词的同时保护他们的隐私。在SPV节点里，这一方法被用来向对等节点发送交易信息查询请求，同时交易地址不会被暴露。(一句话：防止隐私暴露)

##### 举一这样的例子

```
一位手中没有地图的游客需要询问去特定地方的路线。如果他向陌生人询问“教堂街23号在哪 里”， 不经意之间，他就暴露了自己的目的地。Bloom过滤器则会这样问，附近有带‘堂’字的街道吗?”这样的问法 包含了比之前略少的关键词。这位游客可以自己选择包含信息的多少，比如“以‘堂街’结尾”或者“‘教’字开头的街道”。 如果他问得越少，得到了更多可能的地址，隐私得到了保护，但这些地址里面不乏无关的结果;如果他问得非常具 体，他在得到较准 确的结果的同时也暴露了自己的隐私
```

## Bloom的实现细节

Bloom过滤器的实现是由一个可变长度(N)的二进制数组(N位二进制数构成一个位域)和数量可变(M)的一组哈希函数组成。这些哈希函数的输出值始终在1和N之间，该数值与二进制数组相对应。并且该函数为确定性函数，也就是说任何一个使用相同Bloom过滤器的节点通过该函数都能对特定输入得到同一个的结果。Bloom过滤器 的准确性和私密 性能通过改变长度(N)和哈希函数的数量(M)来调节。 在下图中，我们用一个小型的十六位 数组和三个哈希函数(其中K1，K2，K3分别是三个哈希函数，如果还不清楚什么是哈希函数就百度去了解一下)来演示Bloom过滤器的应用原理。

![-w885](media/15330337686333/15330355318432.jpg)

Bloom过滤器数组里的每一个数的初始值为零。关键词被加到Bloom过滤器中之前，会依次通过每一个哈希函数运算一次。该输入经第一个哈希函数运算后得到了一个在1和N之间的数，它在该数组(编号依次为1至N)中所对应的位被置为1，从而把哈希函数的输出记录下来。接着再进行下一个哈希函数的运算，把另外一位置为1;以此类 推。当全部M个哈希函数都运算过之后，一共有M个位的值从0变成了1，这个关键词也被“记录”在了Bloom过滤器里。 下图显示了向上图里的简易Bloom过滤器添加关键词“A”。

![-w880](media/15330337686333/15330375265632.jpg)

向简易Bloom过滤器添加关键词“A”
为测试某一关键词是否被记录在某个Bloom过滤器中，我们将该关键词逐一代入各哈希函数中运算，并将所得的结 果与原数组进行对比。如果所有的结果对应的位都变为了1，则表示这个关键词有可能已被该过滤器记录。之所以 这一结论并不确定，是因为这些字节1也有可能是其他关键词运算的重叠结果。简单来说，Bloom过滤器正匹配代 表着“可能是”。
下图是一个验证关键词“X”是否在前述Bloom过滤器中的图例。相应的比特位都被置为1，所以这个关键词很有可能是匹配的。

![-w881](media/15330337686333/15330376008336.jpg)

上图中在bloom过滤器中测试模式“X”的存在。 结果是一个概率正匹配，意思是“也许”。

另一方面，如果我们代入关键词计算后的结果某位为0，说明该关键词并没有被记录在过滤器里。负匹配的结果不是可能，而是一定。也就是说，负匹配代表着“一定不是”。
(总的来说也就是如果全都是1，表示可能在里面，如果匹配到一个或者多个0，那么肯定没有在里面)

下图是一个验证关键词“Y”是否存在于简易Bloom过滤器中的图例。图中某个结果字段为0，该字段一定没有被匹 配。

![-w882](media/15330337686333/15330380486543.jpg)
